<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1476794678590">{:repl-history {:ide [], :local [&quot;(s/def ::board (s/with-gen\n                 (s/&amp; (s/+ ::row)\n                      #(apply = (map count %)))\n                 (gen/bind\n                   (s/gen pos-int?)\n                   (fn [n]\n                     (s/gen (s/coll-of (s/coll-of cell? :count n))))\n                     )))&quot; &quot;(s/def ::board (s/with-gen\n                 (s/&amp; (s/+ ::row)\n                      #(apply = (map count %)))\n                 (fn [] (gen/bind\n                   (s/gen pos-int?)\n                   (fn [n]\n                     (s/gen (s/coll-of (s/coll-of cell? :count n))))\n                     ))))&quot; &quot;(s/fdef next-state \n        :args (s/cat :board ::board)\n        :ret ::board)&quot; &quot;(s/exercise `next-state)&quot; &quot;(s/exercise (s/get-spec  `next-state))&quot; &quot;(s/fdef next-state\n        :args (s/cat :input ::board)\n        :ret (s/cat :output ::board)\n        :fn (fn [{{input :input} :args {output :output} :ret}]\n              (= (count input) (count output))))&quot; &quot;(defn next-state [board]\n  board)&quot; &quot;(s/exercise (:ret (s/get-spec `next-state)))&quot; &quot;(s/exercise (:args (s/get-spec `next-state)) 1)&quot; &quot;(next-state [[0] [1] [1] [0] [0] [0] [0] [0] [0] [1] [0] [1] [0] [1] [0] [1]])&quot; &quot;(s/fdef next-state\n        :args (s/cat :input ::board)\n        :ret coll?)&quot; &quot;(s/fdef next-state\n        :args ::board\n        :ret coll?)&quot; &quot;(s/exercise-fn `next-state)\n&quot; &quot;(s/fdef next-state\n        :args (s/cat :input ::board)\n        :ret (s/cat :output ::board))&quot; &quot;(s/gen ::board)&quot; &quot;(count (gen/sample (s/gen ::board) 1))&quot; &quot;(first (gen/sample (s/gen ::board) 1))&quot; &quot;(next-state (first (gen/sample (s/gen ::board) 1)))&quot; &quot;(ns game-of-life.core\n  (:require [clojure.spec :as s]\n            [clojure.test.check.generators :as gen]))&quot; &quot;(s/def ::row (s/coll-of cell? :min-count 1))&quot; &quot;(s/exercise-fn next-state 1)&quot; &quot;(s/exercise-fn `next-state 2)&quot; &quot;(first (s/exercise (:args (s/get-spec `next-state))))&quot; &quot;(val (first (s/exercise (:args (s/get-spec `next-state)))))&quot; &quot;(second (first (s/exercise (:args (s/get-spec `next-state)))))&quot; &quot;(map next-state (map first (s/exercise (:args (s/get-spec `next-state)))))&quot; &quot;(map first (s/exercise (:args (s/get-spec `next-state))))&quot; &quot;(pst)&quot; &quot;(stest/instrument `next-state)&quot; &quot;(s/fdef next-state\n        :args ::board\n        :ret ::board)&quot; &quot;(defn next-state [board]\n  nil)&quot; &quot;(s/exercise ::board 1)&quot; &quot;(s/def ::board (s/with-gen\n                 (s/&amp; (s/+ ::row)\n                      #(apply = (map count %)))\n                 #(gen/bind (s/gen pos-int?)\n                             (fn [n]\n                               (s/gen (s/coll-of cell? :count n))))))&quot; &quot;(s/def ::board (s/with-gen\n                 (s/&amp; (s/+ ::row)\n                      #(apply = (map count %)))\n                 #(gen/bind (s/gen pos-int?)\n                             (fn [n]\n                               (s/gen (s/coll-of (s/coll-of cell? :count n)))))))&quot; &quot;(defn next-state [args]\n  nil)&quot; &quot;(first (s/exercise ::board 1))&quot; &quot;(s/fdef next-state\n        :args (s/cat :my-board ::board)\n        :ret ::board)&quot; &quot;(s/fdef next-state\n        :args (s/cat :myboard ::board :int int?)\n        :ret ::board)&quot; &quot;(defn next-state [&amp; args]\n  nil)&quot; &quot;(s/fdef next-state\n        :args (s/cat :myboard ::board)\n        :ret ::board)&quot; &quot;(s/exercise (s/get-spec `next-state))&quot; &quot;(s/fdef next-state\n        :args (s/cat :board ::board)\n        :ret ::board)&quot; &quot;(s/exercise-fn `next-state 1)&quot; &quot;(s/fdef next-state\n        :args (s/cat :board ::board)\n        :ret ::board)\n\n(s/exercise (:args (s/get-spec `next-state)))&quot; &quot;(ns game-of-life.core\n  (:require [clojure.spec :as s]\n            [clojure.test.check.generators :as gen]\n            [clojure.spec.test :as stest]))&quot; &quot;(def cell? #{0 1})&quot; &quot;(s/def ::row (s/coll-of cell? :min-count 1))\n(s/def ::board (s/coll-of ::row))\n&quot; &quot;(s/def ::board (s/with-gen\n                 (s/&amp; (s/+ ::row)\n                      #(apply = (map count %)))\n                 #(gen/bind (s/gen pos-int?)\n                            (fn [n]\n                              (s/gen (s/coll-of (s/coll-of cell? :count n)))))))\n&quot; &quot;(s/exercise (:args (s/get-spec `next-state)))&quot; &quot;(defn next-state [&amp; args]\n  (count args))&quot; &quot;(s/exercise-fn `next-state)&quot; &quot;(def cell? #{0 1})\n(s/def ::row (s/coll-of cell? :min-count 1))\n(s/def ::board (s/&amp; (s/+ ::row)\n                    #(apply = (map count %))))\n(s/def ::board (s/with-gen\n                 (s/&amp; (s/+ ::row)\n                      #(apply = (map count %)))\n                 #(gen/bind (s/gen pos-int?)\n                            (fn [n]\n                              (s/gen (s/coll-of (s/coll-of cell? :count n)))))))\n(s/fdef my-function :args (s/cat :board ::board))\n(defn my-function [board] nil)\n&quot; &quot;(:require [clojure.spec :as s]\n  [clojure.test.check.generators :as gen])&quot; &quot;(require '[clojure.spec :as s]\n  '[clojure.test.check.generators :as gen])&quot; &quot;(def cell? #{0 1})\n(s/def ::row (s/coll-of cell? :min-count 1))\n(s/def ::board (s/&amp; (s/+ ::row)\n                    #(apply = (map count %))))\n(s/def ::board (s/with-gen\n                 (s/&amp; (s/+ ::row)\n                      #(apply = (map count %)))\n                 #(gen/bind (s/gen pos-int?)\n                            (fn [n]\n                              (s/gen (s/coll-of (s/coll-of cell? :count n)))))))\n(s/fdef my-function :args (s/cat :board ::board))\n(defn my-function [board] nil)\n\n&quot; &quot;(s/exercise :args (s/get-spec `my-function) 1)&quot; &quot;(s/exercise :args (s/get-spec `my-function))&quot; &quot;(s/def ::my-coll coll?)&quot; &quot;(s/def ::coll coll?)\n(s/fdef my-function2 :args (s/cat :board ::coll))&quot; &quot;(s/exercise (:args (s/get-spec `my-function2)))&quot; &quot;(s/def ::coll (s/coll-of int?))&quot; &quot;(s/fdef my-function2 :args (s/cat :board ::coll))\n(defn my-function2 [board])\n(s/exercise (:args (s/get-spec `my-function2)))&quot; &quot;(s/def ::coll (s/coll-of (s/coll-of int? :count 4)))&quot; &quot;(s/fdef my-function2 :args (s/cat :board ::coll))\n(defn my-function2 [board])\n(s/exercise (:args (s/get-spec `my-function2)) 1)&quot; &quot;(def cell? #{0 1})\n(s/def ::row (s/coll-of cell? :min-count 1))\n(s/def ::board (s/&amp; (s/+ ::row)\n                    #(apply = (map count %))))\n(s/def ::board (s/with-gen\n                 (s/&amp; (s/+ ::row)\n                      #(apply = (map count %)))\n                 #(gen/bind (s/gen pos-int?)\n                            (fn [n]\n                              (s/gen (s/coll-of (s/coll-of cell? :count n)))))))\n(s/fdef my-function :args (s/cat :board ::board))\n(defn my-function [board])\n&quot; &quot;(def cell? #{0 1})\n(s/def ::row (s/coll-of cell? :min-count 1))\n(s/def ::board (s/&amp; (s/+ ::row)\n                    #(apply = (map count %))))\n(s/def ::board (s/with-gen\n                 (s/&amp; (s/+ ::row)\n                      #(apply = (map count %)))\n                 (fn [] (gen/bind (s/gen pos-int?)\n                                  (fn [n]\n                                    (s/gen (s/coll-of (s/coll-of cell? :count n))))))))\n(s/fdef my-function :args (s/cat :board ::board))\n(defn my-function [board])&quot; &quot;\n(s/exercise-fn `my-function)&quot; &quot;(gen/bind (s/gen pos-int?)\n          (fn [n]\n            (s/gen (s/coll-of (s/coll-of cell? :count n)))))&quot; &quot;(s/gen (s/coll-of (s/coll-of int?)))&quot; &quot;(s/sample (s/gen (s/coll-of (s/coll-of int?))) 1)&quot; &quot;(gen/sample (gen/bind (s/gen pos-int?)\n                      (fn [n]\n                        (s/gen (s/coll-of (s/coll-of cell? :count n))))) 1)&quot; &quot;(gen/sample (gen/bind (s/gen pos-int?)\n                      (fn [n]\n                        (s/gen (s/coll-of (s/coll-of cell? :count 3))))) 1)&quot; &quot;(gen/sample (s/gen (s/coll-of (s/coll-of int?))) 1)&quot; &quot;\n(s/def ::coll (s/coll-of (s/coll-of int?)))\n(s/fdef my-function2 :args (s/cat :board ::coll))\n(defn my-function2 [board])\n(s/exercise (:args (s/get-spec `my-function2)) 1)\n(s/exercise-fn `my-function2)&quot; &quot;(defn my-function2 [board])&quot; &quot;(gen/sample (s/gen (s/coll-of (s/coll-of cell? :count 2))))&quot; &quot;(gen/sample (gen/bind (s/gen pos-int?) #(s/gen (s/coll-of (s/coll-of cell? :count 2)))) 1)&quot; &quot;(gen/sample (gen/bind (s/gen pos-int?) (fn [x] (s/gen (s/coll-of (s/coll-of cell? :count 2))))) 1)&quot; &quot;(gen/sample (s/gen (s/coll-of (s/coll-of cell? :count 2))) 1)&quot; &quot;(gen/sample ::board)&quot; &quot;(gen/sample (s/gen ::board))&quot; &quot;(def cell? #{0 1})\n(s/def ::row (s/coll-of cell? :min-count 1))\n(s/def ::board (s/&amp; (s/+ ::row)\n                    #(apply = (map count %))))&quot; &quot;(s/def ::board (s/with-gen\n                 (s/&amp; (s/+ ::row)\n                      #(apply = (map count %)))\n                 #(gen/bind (s/gen pos-int?)\n                            (fn [n]\n                              (s/gen (s/coll-of (s/coll-of cell? :count n)))))))&quot; &quot;(s/fdef my-function :args (s/cat :board ::board))&quot; &quot;(defn my-function [board] nil)&quot; &quot;(s/exercise (:args (s/get-spec `my-function)))&quot; &quot;(s/exercise (:args (s/get-spec `my-function)) 1)&quot; &quot;(s/exercise-fn `my-function)&quot; &quot;(s/def ::coll (s/coll-of (s/coll-of int? :count 1)))&quot; &quot;(s/fdef my-function2 :args (s/cat :board ::coll))&quot; &quot;(defn my-function2 [board])\n&quot; &quot;(s/exercise-fn `my-function2)&quot; &quot;(s/def ::coll (s/coll-of (s/coll-of int? :count 1)))\n(s/fdef my-function2 :args (s/cat :board ::coll))\n(defn my-function2 [board])\n(s/exercise (:args (s/get-spec `my-function2)) 1)\n(s/exercise-fn `my-function2)&quot; &quot;(s/def ::coll (s/coll-of (s/coll-of int? :count 2)))&quot; &quot;(s/exercise (:args (s/get-spec `my-function2)) 1)&quot; &quot;(gen/sample (s/gen ::coll) 1)&quot; &quot;(gen/sample (s/gen ::coll) 1)\n=&gt; ([[-1 -1] [-1 0] [0 -1] [0 -1] [0 0] [-1 0] [0 0] [-1 -1] [-1 -1] [-1 -1] [-1 0] [-1 0]])\n(gen/sample (s/gen ::board) 1)\n=&gt; ([[0] [0] [1] [0] [1] [0] [1] [0] [1] [0] [0] [0] [0] [1] [0]])&quot; &quot;(gen/sample (s/gen ::board) 1)&quot; &quot;(gen/sample (s/gen ::board) 1)\n=&gt; ([[0 1] [1 1] [1 1] [1 1] [1 1] [0 0] [0 1]])\n&quot; &quot;(gen/sample (s/gen (:args (s/get-spec `my-function))) 1)&quot; &quot;(gen/sample (s/gen (:args (s/get-spec `my-function2))) 1)&quot;], :remote []}}</component>
</project>