<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1476800231938">{:repl-history {:ide [], :local [&quot;(s/fdef next-state\n        :args (s/cat :input ::board)\n        :ret ::board\n        :fn (fn [{{input :input} :args output :ret}]\n              (= input (reverse output)))\n        )&quot; &quot;(s/fdef next-state\n        :args (s/cat :input ::board)\n        :ret ::board\n        :fn (fn [{{input :input} :args output :ret}]\n              (let [input-height (count input)\n                    output-height (count output)\n                    input-width (-&gt; input first count)\n                    output-width (-&gt; output first count)]\n                (and (= input-width output-width)\n                     (= input-height output-height)))))&quot; &quot;(defn next-state [board]\n  (reverse board))&quot; &quot;(stest/check `next-state)&quot; &quot;(-&gt; [1 2 3 4] \n    (map inc)\n    (map dec))&quot; &quot;(-&gt; [1 2 3 4] \n    (map inc))&quot; &quot;(-&gt; [1 2 3 4] \n    (mapper inc))&quot; &quot;(-&gt;&gt; [1 2 3 4]\n     (map inc)\n     (map dec))&quot; &quot;(-&gt;&gt; [1 2 3 4]\n     (map inc)\n     (map dec)\n     (map dec))&quot; &quot;(defn count-live-neighbours [cell-position board])&quot; &quot;(defn next-state [board]\n  (map-indexed (fn [row-index row]\n                 (map-indexed (fn [col-index cell]\n                                (let [live-n (count-live-neighbours {::row-index row-index ::col-index col-index} board)]\n                                  (cond (= cell 0) (if (= live-n 3) 1 0) ;;Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.\n                                        (&lt; live-n 2) 0      ;;Any live cell with fewer than two live neighbours dies, as if caused by under-population.\n                                        (&lt;= live-n 3) 1     ;;Any live cell with two or three live neighbours lives on to the next generation.\n                                        :else 0)))          ;;Any live cell with more than three live neighbours dies, as if by over-population.\n                              row))\n               board))&quot; &quot;(s/def ::row-index pos-int?)&quot; &quot;(s/def ::col-index pos-int?)&quot; &quot;(s/fdef count-live-neighbours\n        :args (s/cat :coords (s/keys :req [::row-index ::col-index])\n                     :board ::board))&quot; &quot;(s/exercise (:args (s/get-spec 'count-live-neighbours)))&quot; &quot;(s/fdef count-live-neighbours\n        :args (s/and (s/cat :coords (s/keys :req [::row-index ::col-index])\n                            :board ::board)\n                     (fn [{:keys [coords board]}]\n                       (let [height (count board)\n                             width (-&gt; board first count)]\n                         (and (&lt; (:row-index coords) height)\n                              (&lt; (:col-index coords) width))))))&quot; &quot;(s/fdef count-live-neighbours\n        :args (s/and (s/cat :coords (s/keys :req [::row-index ::col-index])\n                            :board ::board)\n                     (fn [{:keys [coords board]}]\n                       (let [height (count board)\n                             width (-&gt; board first count)]\n                         (and (&lt; (::row-index coords) height)\n                              (&lt; (::col-index coords) width))))))&quot; &quot;(def max-width 12)\n\n(def max-height 12)&quot; &quot;(s/def ::row (s/coll-of cell? :min-count 1 :max-count max-width))\n\n(s/def ::board (s/with-gen\n                 (s/and (s/coll-of ::row :min-count 1 :max-count max-height)\n                        #(apply = (map count %)))\n                 #(gen/bind (s/gen (s/int-in 1 max-width))\n                            (fn [n]\n                              (s/gen (s/coll-of (s/coll-of cell? :count n)))))))\n&quot; &quot;(s/def ::row-index (s/int-in 1 max-height))\n\n(s/def ::col-index (s/int-in 1 max-width))&quot; &quot;(s/exercise (:args (s/get-spec `count-live-neighbours)))&quot; &quot;(s/fdef count-live-neighbours\n        :args (s/and (s/cat :coords (s/keys :req [::row-index ::col-index])\n                            :board ::board)\n                     (fn [{:keys [coords board]}]\n                       (let [height (count board)\n                             width (-&gt; board first count)]\n                         (and (&lt; (::row-index coords) height)\n                              (&lt; (::col-index coords) width)))))\n        :ret (s/int-in 0 9))&quot; &quot;(filter #{1} (1 0 0 0 1 1 0 0 1))&quot; &quot;(filter #(some #{1} %) (1 0 0 0 1 1 0 0 1))&quot; &quot;(filter #(some #{1} #{%}) (1 0 0 0 1 1 0 0 1))&quot; &quot;(filter pos? (1 0 0 0 1 1 0 0 1))&quot; &quot;(defn neighbours [cell-position board] (list 1 0 0 0 1 1 0 0 1))&quot; &quot;(defn count-live-neighbours [cell-position board]\n  (let [n (neighbours cell-position board)\n        live-n (filter #{1} n)]\n    (count live-n)))&quot; &quot;(stest/check 'count-live-neighbours)&quot; &quot;(filter #{1} '(1 0 0 0 1 1 0 0 1))&quot; &quot;(s/def ::coordinates-and-board (s/and (s/cat :coords (s/keys :req [::row-index ::col-index])\n                                             :board ::board)\n                                      (fn [{:keys [coords board]}]\n                                        (let [height (count board)\n                                              width (-&gt; board first count)]\n                                          (and (&lt; (::row-index coords) height)\n                                               (&lt; (::col-index coords) width))))))&quot; &quot;(s/fdef count-live-neighbours\n        :args ::coordinates-and-board\n        :ret (s/int-in 0 9))&quot; &quot;(stest/check `count-live-neighbours)&quot; &quot;(s/fdef neighbours \n        :args ::coordinates-and-board\n        :ret (s/coll-of #{0 1} :max-count 9))&quot; &quot;(s/fdef neighbours \n        :args ::coordinates-and-board\n        :ret (s/coll-of #{0 1} :min-count 3 :max-count 9))&quot; &quot;(s/exercise (:args (s/get-spec `neighbours)))&quot; &quot;(s/exercise (:ret (s/get-spec `neighbours)))&quot; &quot;(map (+ 2) (-1 0 1))&quot; &quot;(map (+ 2) (list -1 0 1))&quot; &quot;(map #(+ 2 %) (list -1 0 1))&quot; &quot;(map #(+ 0 %) (list -1 0 1))&quot; &quot;(defn neighbours [[row-index col-index] board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        xs (-&gt;&gt; [-1 0 1]\n                (map #(+ col-index %))\n                (filter #(&lt; % 0))\n                (filter #(&gt; % width)))]\n    xs))&quot; &quot;(defn neighbours [{:keys row-index col-index} board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        xs (-&gt;&gt; [-1 0 1]\n                (map #(+ col-index %))\n                (filter #(&lt; % 0))\n                (filter #(&gt; % width)))]\n    xs))&quot; &quot;(defn neighbours [{:keys [row-index col-index]} board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        xs (-&gt;&gt; [-1 0 1]\n                (map #(+ col-index %))\n                (filter #(&lt; % 0))\n                (filter #(&gt; % width)))]\n    xs))&quot; &quot;(defn neighbours [cell-position board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt; % 0))\n                (filter #(&gt; % width)))]\n    xs))&quot; &quot;(s/fdef neighbours\n        :args ::coordinates-and-board\n        :ret coll?)&quot; &quot;(s/fdef neighbours\n        :args ::coordinates-and-board\n        :ret (s/coll-of #{0 1} :min-count 3 :max-count 9))&quot; &quot;(defn neighbours [cell-position board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= % 0))\n                (filter #(&gt; % width)))\n        ys (-&gt;&gt; [-1 0 1]\n                (map #(+ (::row-index cell-position) %))\n                (filter #(&lt;= % 0))\n                (filter #(&gt; % width)))]\n    xs))&quot; &quot;(get-int [[1 2 3] [1 2 3] [1 2 3]] [2 2])&quot; &quot;(get-in [[1 2 3] [1 2 3] [1 2 3]] [2 2])&quot; &quot;(get-in [[1 2 3] [1 2 3] [1 2 3]] [1 2])&quot; &quot;(get-in [[1 2 3] [1 2 3] [1 2 3]] [1 1])&quot; &quot;(defn neighbours [cell-position board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= % 0))\n                (filter #(&gt; % width)))\n        ys (-&gt;&gt; [-1 0 1]\n                (map #(+ (::row-index cell-position) %))\n                (filter #(&lt;= % 0))\n                (filter #(&gt; % width)))]\n    (map (fn [x y] \n           (get-in board x y)))))&quot; &quot;(defn neighbours [cell-position board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= % 0))\n                (filter #(&gt; % width)))\n        ys (-&gt;&gt; [-1 0 1]\n                (map #(+ (::row-index cell-position) %))\n                (filter #(&lt;= % 0))\n                (filter #(&gt; % width)))]\n    (map (fn [x y]\n           (get-in board x y)) xs ys)))&quot; &quot;(s/fdef count-live-neighbours\n        :args ::coordinates-and-board\n        :ret (s/int-in 0 10))&quot; &quot;(defn neighbours [cell-position board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= % 0))\n                (filter #(&gt; width %)))\n        ys (-&gt;&gt; [-1 0 1]\n                (map #(+ (::row-index cell-position) %))\n                (filter #(&lt;= % 0))\n                (filter #(&gt; height %)))]\n    (map (fn [x y]\n           (get-in board x y)) xs ys)))&quot; &quot;(s/fdef neighbours\n        :args ::coordinates-and-board\n        :ret (s/coll-of #{0 1} :min-count 0 :max-count 9))&quot; &quot;(stest/check `neighbours 1)&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  [])&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt; [-1 0 1] \n               (map #(+ (::col-index cell-position) %)))]))&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt; [-1 0 1] \n               (map #(+ (::col-index cell-position) %)))]\n    xs))&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt;&gt; [-1 0 1] \n               (map #(+ (::col-index cell-position) %)))]\n    xs))&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt; 0 % width)))]\n    xs))&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= 0 % width)))]\n    xs))&quot; &quot;(get-neighbour-coordinates {::col-index 2 ::row-index 2} 3 3)&quot; &quot;(get-neighbour-coordinates {::col-index 3 ::row-index 2} 3 3)&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= 0 % width)))\n        ys (-&gt;&gt; [-1 0 1]\n                (map #(+ (::row-index cell-position) %))\n                (filter #(&lt;= 0 % height)))]\n    (map (fn [x y] [x y]) xs ys)))&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= 0 % width)))\n        ys (-&gt;&gt; [-1 0 1]\n                (map #(+ (::row-index cell-position) %))\n                (filter #(&lt;= 0 % height)))]\n    (for [x xs y ys] [x y])))&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= 0 % width)))\n        ys (-&gt;&gt; [-1 0 1]\n                (map #(+ (::row-index cell-position) %))\n                (filter #(&lt;= 0 % height)))]\n    (filter (comp not #{cell-position}) (for [x xs y ys] [x y]))))&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= 0 % width)))\n        ys (-&gt;&gt; [-1 0 1]\n                (map #(+ (::row-index cell-position) %))\n                (filter #(&lt;= 0 % height)))]\n    (filter (not= cell-position) (for [x xs y ys] [x y]))))&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= 0 % width)))\n        ys (-&gt;&gt; [-1 0 1]\n                (map #(+ (::row-index cell-position) %))\n                (filter #(&lt;= 0 % height)))]\n    (filter #(not= cell-position %) (for [x xs y ys] [x y]))))&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= 0 % width)))\n        ys (-&gt;&gt; [-1 0 1]\n                (map #(+ (::row-index cell-position) %))\n                (filter #(&lt;= 0 % height)))]\n    (filter #(not= [(::col-index cell-position) (::row-index cell-position)] %) \n            (for [x xs y ys] [x y]))))&quot; &quot;(get-neighbour-coordinates {::col-index 0 ::row-index 2} 3 3)&quot; &quot;(get-neighbour-coordinates {::col-index 1 ::row-index 2} 3 3)&quot; &quot;(get-neighbour-coordinates {::col-index 0 ::row-index 0} 0 0)&quot; &quot;(get-neighbour-coordinates {::col-index 0 ::row-index 0} 1 1)&quot; &quot;(defn neighbours [cell-position board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        n-coords (get-neighbour-coordinates cell-position width height)]\n    (map (fn [[x y]] (get-in board x y)) n-coords)))&quot; &quot;(defn neighbours [cell-position board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        n-coords (get-neighbour-coordinates cell-position width height)]\n    (map (fn [x] x) n-coords)))&quot; &quot;(get-neighbour-coordinates {::col-index 0 ::row-index 0} 3 3)&quot; &quot;(map (fn [[x y]] x) (get-neighbour-coordinates {::col-index 0 ::row-index 0} 3 3))&quot; &quot;(map (fn [[x y]] y) (get-neighbour-coordinates {::col-index 0 ::row-index 0} 3 3))&quot; &quot;(defn neighbours [cell-position board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        n-coords (get-neighbour-coordinates cell-position width height)]\n    (map (fn [[x y]] 0) n-coords)))&quot; &quot;(defn neighbours [cell-position board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        n-coords (get-neighbour-coordinates cell-position width height)]\n    (map (fn [[x y]] (get-in board y x)) n-coords)))&quot; &quot;(get-neighbour-coordinates {::col-index 0 ::row-index 0} 3 3 )&quot; &quot;(defn neighbours [cell-position board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        n-coords (get-neighbour-coordinates cell-position width height)]\n    (map (fn [[x y]] x) n-coords)))&quot; &quot;(neighbours {::col-index 0 ::row-index 0} [[0 0 0] [0 0 0] [0 0 0]])&quot; &quot;(defn neighbours [cell-position board]\n  (let [height (count board)\n        width (-&gt; board first count)\n        n-coords (get-neighbour-coordinates cell-position width height)]\n    (map (fn [[x y]] (get-in board [y x])) n-coords)))&quot; &quot;(stest/check `neighbours)&quot; &quot;(s/exercise `next-state)&quot; &quot;(s/exercise `next-state 1)&quot; &quot;(s/exercise-fn `next-state 1)&quot; &quot;(s/def ::cell-position (s/keys :req [::row-index ::col-index]))&quot; &quot;(s/def ::coordinates-and-board (s/and (s/cat :coords ::cell-position\n                                             :board ::board)\n                                      (fn [{:keys [coords board]}]\n                                        (let [height (count board)\n                                              width (-&gt; board first count)]\n                                          (and (&lt; (::row-index coords) height)\n                                               (&lt; (::col-index coords) width))))))&quot; &quot;(s/fdef get-neighbour-coordinates ::args )&quot; &quot;(s/fdef get-neighbour-coordinates ::args (s/cat :coords ::cell-position \n                                                :width pos-int?\n                                                :height pos-int?)\n        :ret  (s/coll-of (s/tuple #{0 1}) :min-count 0 :max-count 9))&quot; &quot;(s/fdef get-neighbour-coordinates \n        :args (s/cat :coords ::cell-position \n                                                :width pos-int?\n                                                :height pos-int?)\n        :ret  (s/coll-of (s/tuple #{0 1}) :min-count 0 :max-count 9))&quot; &quot;(s/fdef get-neighbour-coordinates \n        :args (s/cat :coords ::cell-position \n                                                :width pos-int?\n                                                :height pos-int?)\n        :ret  (s/coll-of (s/tuple pos-int? pos-int?) :min-count 0 :max-count 9))&quot; &quot;(s/exercise-fn `get-neighbour-coordinates)&quot; &quot;(defn get-neighbour-coordinates [cell-position width height]\n  (let [xs (-&gt;&gt; [-1 0 1]\n                (map #(+ (::col-index cell-position) %))\n                (filter #(&lt;= 0 % (dec width))))\n        ys (-&gt;&gt; [-1 0 1]\n                (map #(+ (::row-index cell-position) %))\n                (filter #(&lt;= 0 % (dec height))))]\n    (filter #(not= [(::col-index cell-position) (::row-index cell-position)] %)\n            (for [x xs y ys] [x y]))))&quot; &quot;(next-state [[0 0 0 0 0 0]\n             [0 1 1 0 0 0]\n             [0 1 1 0 0 0]\n             [0 0 0 1 1 0]\n             [0 0 0 1 1 0]\n             [0 0 0 0 0 0]])&quot; &quot;(s/exercise-fn `next-state)&quot;], :remote []}}</component>
</project>